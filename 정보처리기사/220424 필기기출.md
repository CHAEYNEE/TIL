# 💬정처기 필기 기출 정리

### ◼ 2022년 4월 24일 기출

1과목 : [소프트웨어 설계](#소프트웨어-설계)
<br>
2과목 : [소프트웨어 계발](#소프트웨어-개발)
<br>
3과목 : [데이터베이스 구축](#데이터베이스-구축)
<br>
4과목 : [프로그래밍 언어 활용](#프로그래밍-언어-활용)
<br>
5과목 : [정보시스템 구축관리](#정보시스템-구축관리)

#### 소프트웨어 설계

1. UML 다이어그램 중 순차 다이어그램
   <br>

- 객체 간의 동적 상호작용을 시간 개념을 중심으로 모델링 하는 것이다.
- 일반적으로 다이어그램의 수직 방향이 시간의 흐름을 나타낸다
- 회귀 메시지(Self-Message), 제어블록(Statement block)등으로 구성된다.
- 순차 다이어그램은 행위 다이어그램이므로 동적이고, 순차적인 표현을 위한 다이어그램이다.
  <br>
  <br>

2. 메시지 지향 미들웨어(Message-Oriented Middleware, MOM)
   <br>

- 독립적인 애플리케이션을 하나의 통합된 시스템으로 묶기 위한 역할을 한다.
- 송신측과 수신측의 연결 시 메시지 큐를 활용하는 방법이 있다.
- 상이한 애플리케이션 간 통신을 비동기 방식으로 지원한다.
- 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어이다.
- 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용한다.
- 즉각적인 응답을 원하는 경우가 아니라 다소 느리고 안정적인 응답을 필요로 하는 경우에 많이 사용된다.
  <br>
  <br>

3. 익스트림 프로그래밍
   <br>

- Agile 방법론 중 하나이다.
- 소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법이다.
- 익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것이다.
- 구체적인 실천 방법을 정의하고 있으며, 개발 문서보다는 소스 코드 중점을 둔다.
  <br>
  <br>

4. 유스케이스(Use Case)의 구성 요소간의 관계
   <br>

- 연관 관계(Association) : 유스케이스와 액터간의 상호작용이 있음을 표현한다.
- 포함 관계(Include) : 하나의 유스케이스가 다른 유스케이스의 실행을 전제로 할 때 형성되는 관계이다.
- 확장 관계(Extend) : 확장 기능 유스케이스와 확장 대상 유스케이스 사이에 형성 되는 관계이다.
- 일반화 관계(Generalization) : 유사한 유스케이스 또는 액터를 모아 추상화한 유스케이스 또는 액터와 연결시켜 그룹을 만들어 이해도를 높이기 위한 관계이다.
  <br>
  <br>

5. 기능적 요구 vs 비기능적 요구
   <br>

- 기능적 요구 : 시스템이 실제로 어떻게 동작하는지 관점을 둔 요구사항
- 비기능적 요구 : 시스템 구축에 대한 성능, 보안. 품질, 안정 등에 대한 성능, 보안, 품질, 안전성등으로 실제 수행에 보조적인 요구사항
- 시스템 처리량, 반응 시간 등의 성능 요구나 품질 요구는 비기능적 요구에 해당한다.
- '차량 대여 시스템이 제공하는 모든 화면이 3초 이내에 사용자에게 보여야 한다'는 비기능적 요구이다.
- 시스템 구축과 관련된 안전, 보안에 대한 요구사항들은 비기능적 요구에 해당한다.
- '금융 시스템의 조회, 인출, 입금, 송금의 기능이 있어야 한다'는 기능적 요구이다.
  <br>
  <br>

6. 정보공학 방법론에서 데이터베이스 설계의 표현으로 사용하는 모델링 언어는?
   <br>

- Entity-Relationship Diagram : 정보공학방법론
- Package Diagram : uml다이어그램
- State Transition Diagram : uml다이어그램
- Deployment Diagram : uml다이어그램
  <br>
  <br>

7. 미들웨어
   <br>

- 클라이언트와 서버 간의 통신을 담당하는 시스템 소프트웨어이다.
- 이기종 하드웨어, 소프트웨어, 네트웤, 프로토콜, PC환경, 운영체제 환경 등에서 시스템 간의 표준화된 연결을 도와주는 소프트웨어이다.
- 표준화 된 인터페이스를 통하여 시스템 간의 데이터 교환에 있어 일관성을 제공한다.
- 운영체제와 애플리케이션 사이에서 중간 매개 역할을 하는 다목적 소프트웨어이다.
- 사용자가 미들웨어의 정보 교환 방법 등의 내부 동작을 쉽게 확인할 수 있다면, 보안의 위협이 될 수 있으므로 확인할 수 없도록 해야한다.
- 소프트웨어 컴포넌트를 연결하기 위한 준비된 인프라 구조를 제공한다.
- 여러 컴포넌트를 1대 1, 1대 다, 다대 다 등 여러가지 형태로 연결이 가능하다.
  <br>
  <br>

8. UI설계지침
   <br>

- 사용자 중심 : 사용자가 이해하기 쉽고 편하게 사용할 수 있는 환경을 제공해 실 사용자에 대한 이해가 바탕이 되어야 함
- 일관성 : 버튼이나 조작 방법을 사용자가 기억하기 빠르고 쉽게 습득할 수 있도록 설계해야 함
- 단순성 : 조작 방법은 가장 간단하게 작동되도록 하여 인지적 부담 최소화
- 결과 예측 가능 : 작동시킬 기능만 보고도 결과 예측이 가능해야 함
- 가시성 : 주요 기능을 메인 화면에 노출하여 쉬운 조작이 가능해야 함
- 표준화 : 디자인을 표준화하여 기능 구조의 선행 학습 이후 쉽게 사용 가능해야 함
- 접근성 : 사용자의 직무, 연령, 성별 등이 고려된 다양한 계층을 수용해야 함
- 명확성 : 사용자가 개념적으로 쉽게 인지해야함
- 오류 발생 해결 : 사용자가 오류에 대한 상황을 정확하게 인지할 수 있어야 함
  <br>
  <br>

9. 객체지향 개념 - 다형성
   <br>

- 다형성은 현재 코드를 변경하지 않고 새로운 클래스를 쉽게 추가할 수 있게 한다.
- 다형성이란 여러 가지 형태를 가지고 있다는 의미로, 여러 형태를 받아들일 수 있는 특징을 말한다.
- 메소드 오버라이딩 : 상위 클래스에서 정의한 일반 메소드의 구현을 하위 클래스에서 무시하고 재정의 가능, 상속관계에서만 발생
- 메소드 오버로딩 : 한 클래스 내에서 메소드의 이름은 동일하지만 매개변수의 수나 타입을 다르게 하여 재정의 하는 것
  <br>
  <br>

10. 소프트웨어 개발 영역 결정 요소 - 인터페이스
    <br>

- 소프트웨어에 의해 간접적으로 제어되는 장치와 소프트웨어를 실행하는 하드웨어
- 기존의 소프트웨어와 새로운 소프트웨어를 연결하는 소프트웨어
- 순서적 연산에 의해 소프트웨어를 실행하는 절차
  <br>
  <br>

11. 객체
    <br>

- 상태, 동작, 고유 식별자를 가진 모든 것
- 필요한 자료 구조와 수행되는 함수들을 가진 하나의 독립된 존재
- 상태는 속성값에 의해 정의
  <br>
  <br>

12. 객체지향 개념
    <br>

- 상속(Inheritance) : 이미 정의된 상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받는 것
- 클래스(Class) : 하나 이상의 유사한 객체들을 묶는 것
- 캡슐화(Encapsulation) : 서로 관련성이 많은 데이터들과 연산을 묶는 것
- 연관관계(Association) : 2개 이상의 사물이 서로 관련되어 있음을 표현
  <br>
  <br>

13. Agile 프로세스 모델
    <br>

- 개발에 대한 개념적 방법론
- 개발 프로젝트 기간을 짧은 주기로 나눠 반복적인 개발을 하는 것이 특징
- 고객 관점의 효율적이고 민첩한 변화 대응을 중시
- 프로세스, 도구보다는 사람과 상호작용을
- 광범위한 문서보다는 실제 작동하는 제품을
- 계약 협상보다는 고객 협력을
- 계획을 따르기보다는 변화대응을
  <br>
  <br>

14. 컴포넌트
    <br>

- 프로그래밍에 있어서 재사용이 가능한 각각의 독립된 모듈
- 특정 기능 수행을 위해 독립적으로 분리
  <br>
  <br>

15. GoF(Gang of Four)디자인 패턴 : 생성, 구조, 행동패턴의 세 그룹으로 분류
    <br>

- 생성패턴 : 추상 팩토리 패턴, 빌더 패턴, 팩토리 메소드 패턴, 프로토타입 패턴, 싱글톤 패턴
- 구조패턴 : 어댑터 패턴, 브릿지 패턴, 컴포지트 패턴, 데코레이터 패턴, 퍼사드 패턴, 플라이웨잇 패턴, 프록시 패턴
- 행위 패턴 : 역할 사슬 패턴, 커맨드 패턴, 인터프리터 패턴, 이터레이터 패턴, 미디에이터 패턴, 메멘토 패턴, 옵저버 패턴, 상태 패턴, 전략 패턴, 템플릿 메소드 패턴, 비지터 패턴
  <br>
  <br>

  16. UI 관련 기본 개념 - Feedback
      <br>

  - 시스템의 상태와 사용자의 지시에 대한 효과를 보여주어 사용자가 명령에 대한 진행 상황과 표시된 내용을 해석할 수 있도록 도와주는 것
    <br>
    <br>

  17. 사용자 인터페이스(UI)의 구분
      <br>

  - CLI : 텍스트 형태 인터페이스
  - GUI : 마우스로 선택하여 작업하는 그래픽 환경 인터페이스
  - NUI : 사용자의 말이나 행동으로 기기 조작하는 인터페이스
  - VUI : 사람의 음성으로 기기 조작하는 인터페이스
  - OUI : 모든 사물과 사용자 간의 상호작용을 위한 인터페이스
    <br>
    <br>

18. 소프트웨어 모델링
    <br>

- 모델링 작업의 결과물은 다른 모델링 작업에 영향을 줄 수 있음
- 구조적 방법론에서는 DFD, DD등을 사용하여 요구사항의 결과를 표현함
- 객체지향 방법론에서는 UML 표기법 사용
- 소프트웨어 모델 사용할 경우 개발 될 소프트웨어에 대한 이해도 및 이해 당사자 간의 의사소통 향상에 도움이 됨
  <br>
  <br>

19. 유스케이스 다이어그램
    <br>

- 액터 : 시스템과 상호작용하는 모든 외부요소, 사람이나 외부 시스템 의미
- 사용자 측면에서의 요구사항으로 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술
- 시스템 액터는 다른 프로젝트에서 이미 개발되어 사용되고 있으며, 본 시스템과 데이터를 주고받는 등 서로 연동되는 시스템을 말함
- 액터가 인식할 수 없는 시스템 내부의 기능을 하나의 유스케이스로 파악해서는 안됨
  <br>
  <br>

20. MVC
    <br>

- 사용자 인터페이스를 담당하는 계층의 응집도를 높일 수 있고 여러 개의 다른 UI를 만들어 그 사이에 결합도를 낮출 수 있음
- 전달자 역할은 제어가
- 뷰는 모델 데이터를 사용자 인터페이스에 보이는 역할을 담당
- 제어는 모델에 명령을 보냄으로써 모델의 상태를 변경할 수 있음
  <br>
  <br>
  <br>
  <br>
  <br>

#### 소프트웨어 개발

21. 통합 테스트
    <br>

- 상향식 통합 테스트
  - 프로그램 하위 모듈에서 상위 모듈 방향으로 통합
  - 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터 필요
- 하향식 통합 테스트

  - 상위 모듈에서 하위 모듈 방향으로 통합
  - 깊이 우선 통합법, 넓이 우선 통합법 사용
  - 초기부터 사용자에게 시스템 구조를 보여줌
  - 모듈 간의 인터페이스와 시스템의 동작이 정상적으로 잘되고 있는지를 빨리 파악하고자 할 때 상향식 보다 하향식 통합 테스트를 사용하는 것이 좋음
    <br>
    <br>

22. 이진 검색 방법
    <br> 1. 배열의 중갑 값을 찾음 2. 중간 값과 검색 값을 비교 1. 중간 값이 검색 값과 같으면 끝 2. 중간 값보다 검색 값이 크다면 오른쪽 구간을 탐색 3. 중간 값보다 검색 값이 작다면 왼쪽 구간을 탐색 3. 값을 찾거나 간격이 비었을 때까지 반복
    <br>
    ex) 1-15까지 있을 때 14 찾기
    <br>
    1번째: 1+15/2 = 8
    <br>
    2번째: 9+15/2 = 12
    <br>
    3번째: 13+15/2 = 14(14를 찾았으므로 이진 검색 종료)
    <br>
    <br>

23. 워크스루 & 인스펙션
    <br>

- 워크스루 : 요구사항 명세서 작성자를 포함하여 사전 검토한 후 짧은 검토 회으를 통해 결함 발견
- 인스펙션 : 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함 발견
  <br>
  <br>

24. 복호화, 저작권, 크랙, 형상관리
    <br>

- 복호화 : 디코딩, 즉 부호화된 데이터를 부호화 되기 전 형태로 바꾸어, 사람이 읽을 수 있는 형태로 되돌려 놓는 것
- 저작권 : 창작물을 만든이가 자기 저작물에 대해 가지는 법적 권리
- 크랙 : 소프트웨어를 수정하여 소프트웨어를 크랙하는 사람이 원하지 않는 기능들, 보통은 수정 방식(복사 보호. 소프트웨어 조작 보호)을 비활성화하거나 제거하는 일
- 형상관리 : 소프트웨어 개발과정에서 소프트웨어의 변경사항을 관리하기 위해 개발된 일련의 활동
  <br>
  <br>

25. 테스트 케이스
    <br>

- 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서
- 테스트의 목표 및 테스트 방법을 결정하고 테스트 케이스를 작성해야 함 -프로그램에 결함이 있더라도 입력에 대해 정상적인 결과를 낼 수 있기 때문에 결함을 검사할 수 있는 테스트 케이스를 찾는 것이 중요
- 테스트 케이스 실행이 통과되었는지 실패하였는지 판단하기 위한 기준을 테스트 오라클이라고 함
  <br>
  <br>

26. 객체지향 개념 활용한 소프트웨어 구현
    <br>

- JAVA에서 정보은닉을 표기할 때 private의 의미는 외부에서 클래스 내부 정보로 접근하지 못하도록 하는 접근금지임 -객체란 필요한 자료 구조와 수행되는 함수들을 가진 하나의 독립된 존재
- 상속은 개별 클래스를 상속 관계로 묶음으로써 클래스 간의 체계화된 전체 구조를 파악하기 쉽다는 장점이 있음
- 같은 클래스에 속하는 개개의 객체이자 하나의 클래스에서 생성된 객체를 인스턴스라고 함
  <br>
  <br>

27. DRM
    <br>

- 디지털 콘텐츠의 지적재삭권보호, 관리 기능 및 안전한 유통과 배포를 보장하는 솔루션
- 디지털 콘텐츠의 지적재산권을 보호하는 권한통제기술, 사용권한제어 기술, 패키징 기술, 라이선스 관리를 포함한 유통체계
- 디지털 콘텐츠와 디바이스 사용을 제한하기 위해 하드웨어 제조업자, 저작권자, 출판업자 등이 사용할 수 있는 접근 제어 기술
- 클리어링 하우스는 사용자에게 콘텐츠 라이센스를 발급하고 권한을 부여해주는 시스템을 말함
  <br>
  <br>

28. 위험 모니터링
    <br>

- 위험 요소 징후들에 대하여 계속적으로 인지하는 것
  <br>
  <br>

29. RCS
    <br>

- CVS와 차이점은 소스 파일의 수정을 한 사람만으로 제한
- 다수의 사용자가 동시에 파일 수정을 할 수 없도록 파일 자금 방식으로 버전을 관리하는 도구
- 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있음
  <br>
  <br>

30. 화이트박스 테스트
    <br>

- 화이트박스 테스트의 이해를 위해 논리흐름도를 이용할 수 있음
- 테스트 데이터를 이용해 실제 프로그램을 실행함으로써 오류를 찾는 동적 테스트에 해당
- 테스트 데이터를 선택하기 위하여 검증기준을 정함
  <br>

  cf) 블랙박스 테스트

  - 프로그램 구조를 고려하지 않기 떄문에 테스트 케이스는 프로그램 또는 모듈의 요구나 명세를 기초로 결정
    <br>
    <br>

31. 알고리즘
    <br>

- 주어진 작업을 수행하는 컴퓨터 명령어를 순서대로 나열한 것으로 볼 수 있음
- 검색 : 정렬이 되지 않은 데이터 혹은 정렬이 된 데이터 중에서 키값에 해당하는 데이터를 찾는 알고리즘
- 정렬 : 흩어져 있는 데이터를 키값을 이용하여 순서대로 열거하는 알고리즘
- 선형 검색 : 처음부터 끝까지 하나씩 순서대로 비교하며 원하는 값을 찾아내는 검색
- 이진 검색 : 검색을 수행하기 전 반드시 데이터의 집합이 정렬되어 있어야 함
  <br>
  <br>

32. 버블 정렬
    <br>

- 첫 위치부터 시작해서 오른쪽값과 비교
  <br>
  <br>

33. 인스펙션 과정
    <br> 1. 계획 2. 사전교육 3. 준비 4. 인스펙션 회의 5. 수정 6. 후속조치
    <br>
    <br>

34. 리팩토링
    <br>

- 소프트웨어를 보다 쉽게 이해할 수 있고 적은 비용으로 수정할 수 있도록 겉으로 보이는 동작의 변화 없이 내부구조를 변경하는 것
  <br>
  <br>

35. 단위 테스트
    <br>

- 구현 단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트함
- 모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행
- 테스트 드라이버 : 필요 데이터를 인자를 통해 넘겨주고 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈
- 테스트 스텁 : 인자를 통해 받은 값을 가지고 수행한 후 그 결과를 테스트할 모듈에 넘겨주는 역할
  <br>
  <br>

36. IDE 도구
    <br>

- Coding : 프로그래밍 언어를 가지고 컴퓨터 프로그램을 작성할 수 있는 환경을 제공
- Compile : 주어진 언어로 작성된 컴퓨터 프로그램을 다른 언어의 동등한 프로그램으로 변환하는 기능, 고급언어 -> 저급언어로
- Debugging : 프로그램에서 발견되는 버그를 찾아 수정할 수 있는 기능
- Deployment : 소프트웨어를 최종 사용자에게 전달하기 위한 기능
  <br>
  <br>

37. 전위, 중위, 후위 순회
    <br>

- 전위 순회 : Root, Left, Right 순서
- 중위 순회 : Left, Root, Right 순서
- 후위 순회 : Left, Right, Root 순서
  <br>
  <br>

38. JSON
    <br>

- 속성-값 쌍으로 이루어진 데이터 오브젝트를 전달하기 위해 사용하는 개방형 표준 포맷
- AJAX에서 많이 사용되고 XML을 대체하는 주요 데이터 포맷
- 언어 독립형 데이터 포맷으로 다양한 프로그래밍 언어에서 사용
  <br>
  <br>

39. Tree, Graph, Stack, Queue
    <br> 1. Stack = LIFO, 한 쪽 끝에서 일어남 2. Queue = FIFO, 양방향에서 일어남 3. Tree & Graph 는 비선형구조
    <br>
    <br>

40. 단위 테스트 도구
    <br>

- CppUnit : C++ 프로그래밍 언어용 단위 테스트 도구
- JUnit : 자바 프로그래밍 언어용 단위 테스트 도구
- HttpUnit : 웹 브라우저 없이 웹 사이트 테스트를 수행하는 데 사용되는 오픈 소스 소프트웨어 테스트 프레임워크
  <br>
  <br>
  <br>
  <br>
  <br>

#### 데이터베이스 구축

41. 정규화 과정 [도부이결다조]

- 1NF : 모든 *도*메인이 원자 값으로만 구성
- 2NF : 기본키가 아닌 속성이 기본키에 대한 완전 함수적 종속을 만족, *부*분적 함수 종속을 제거한 정규형
- 3NF : 기본키가 아닌 모든 속성이 기본키에 대해 *이*행적 함수 종속 관계를 만족하지 않는 정규형
- BCNF : 모든 *결*정자가 후보키인 정규형, 종속성 보존X
- 4NF : *다*치 종속이 성립하는 경우, R의 모든 속성이 A에 함수적 종속 관계를 만족
- 5NF : 모든 *조*인 종속이 R의 후보키를 통해서만 성립되는 정규형
  <br>
  <br>

42. 트랜잭션의 특성

- 원자성(Atomicity) : 완전하게 수행 완료되지 않으면 전혀 수행되지 않아야 함
- 일관성(Consistency) : 시스템의 고정 요소는 트랜잭션 수행 전후에 같아야 함
- 격리성(Isolation, 고립성) : 트랜잭션 실행 시 다른 트랜잭션의 간섭을 받지 않아야 함
- 영속성(Durability, 지속성) : 트랜잭션의 완료 결과가 데이터베이스에 영구히 기억됨
  <br>
  <br>

43. 분산 데이터베이스

- 물리적으로 분산된 데이터베이스 시스템을 논리적으로 하나의 데이터베이스 시스템처럼 사용할 수 있도록 한 것
- 물리적으로 분산되어 지역별로 필요한 데이터를 처리할 수 있는 지역 컴퓨터를 분산 처리기라고 함
- 분산 데이터베이스 시스템을 위한 통신 네트워크 구조가 데이터 통신에 영향을 주므로 효율적으로 설계해야 함
- 위치 투명성(Location Transparency)：하드웨어와 소 프트웨어의 물리적 위치를 사용자가 알 필요가 없음
- 중복(복제) 투명성(Replication Transparency)：사용 자에게 통지할 필요없이 시스템 안에 파일들과 자원들의 부가적인 복사를 자유롭게 할 수 있음
- 병행 투명성(Concurrency Transparency)：다중 사용 자들이 자원들을 자동으로 공유할 수 있음
- 장애 투명성(Fai ure Transparency)：사용자들은 어느 위치의 시스템에 장애가 발생했는지 알 필요가 없음
  <br>
  <br>

44. SQL

- 정렬은 ORDER BY
- 내림차순 : ASC 혹은 생략
- 오름차순 : DESC
  <br>
  <br>

45. 데이터베이스의 인덱스

- 문헌의 색인, 사전과 같이 데이터를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조
- 테이블에 붙여진 색인으로 데이터 검색 시 처리 속도 향상에 도움이 됨
- 대부분의 데이터베이스에서 테이블을 삭제하면 인덱스도 같이 삭제됨
- 인덱스 생성 : CREATE
- 인덱스 삭제 : DROP
  <br>
  <br>

46. 저장 레코드 양식 설계시 고려 사항

- 데이터 타입, 데이터 값의 분포, 접근 빈도
  <br>
  <br>

47. DCL, DDL, DML
    <br>

        1. DCL

        - COMMIT : 명령어로 수행된 결과를 실제 물리적 디스크로 저장하고, 명령어로 수행을 성공적으로 완료하였음을 선언한다.
        - ROLLBACK : 명령어로 수행을 실패하였음을 알리고, 수행된 결과를 원상복구시킨다.
        - GRANT : 데이터베이스 사용자에게 사용 권한 부여한다.
        - REVOKE : 데이터베이스 사용자로부터 사용 권한 취소한다.

        2. DDL

        - CREATE : SCHEMA(스키마), DOMAIN(도메인), TABLE(테이블), VIEW(뷰), INDEX(인덱스)를 정의
        - ALTER : TABLE에 대한 정의를 변경하는 데 사용
        - DROP : SCHEMA(스키마), DOMAIN(도메인), TABLE(테이블), VIEW(뷰), INDEX(인덱스)를 삭제

        3. DML

        - SELECT : 테이블에서 조건에 맞는 튜플을 검색
        - INSERT : 테이블에 새로운 튜플을 삽입
        - DELETE : 테이블에서 조건에 맞는 튜플을 삭제
        - UPDATE : 테이블에서 조건에 맞는 튜플의 내용 변경

    <br>
    <br>

48. 데이터 사전

- 시스템 자신이 필요로 하는 여러가지 객체(기본 테이블, 뷰, 인덱스, 데이터베이스, 패키지, 접근 권한 등)에 관한 정보를 포함하고 있는 시스템 데이터베이스
- 시스템 카탈로그, 메타 데이터라고도 함
- 시스템 카탈로그 자체도 시스템 테이블로 구성되어 있어 SQL문을 이용하여 내용 검색 가능
- 사용자가 직접 시스템 카탈로그를 갱신할 수 없음
- SQL문으로 여러가지 객체에 변화를 주면 시스템이 자동 갱신
- 데이터 사전에 있는 데이터에 실제로 접근하는 데 필요한 위치 정보는 데이터 디렉토리라는 곳에서 관리
  <br>
  <br>

49. 데이터베이스 릴레이션의 특징

- 튜플의 유일성 : 모든 튜플은 서로 다른값을 갖음
- 튜플의 무순서성 : 하나의 릴레이션에 튜플 순서는 없음
- 속성의 원자성 : 속성값은 원자값을 갖음
- 속성의 무순서성 : 각 속성은 릴레이션내에서 유일한 이름을 가지며 순서는 큰 의미 없음
  <br>
  <br>

50. 뷰

- 뷰는 다른 뷰를 기반으로 새로운 뷰 만들 수 있음
- 뷰는 일종의 가상 테이블이며 update에는 제약 따름
- 뷰는 기본 테이블을 만드는 것처럼 CRATE VIEW를 사용해 만들 수 있음
- 뷰는 논리적으로만 존재함
  <br>
  <br>

51. Committed, Partially Committed

- Partially Committed: 마지막 연산이 실행된 직후의 상태로 아직 Commit 연산 실행 전
- Committed: 트랜잭션이 실행을 성공적으로 완료하여 Commit 연산을 수행한 상태
  <br>
  <br>

52. DML, DCL, DDL 구분
    <br>
    <br>

53. Super key, Candidate key

- Super key(슈퍼키) - 속성들의 집합으로 구성된 키, 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않음
- Candidate key(후보키) - 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합
  <br>
  <br>

54. 데이터베이스 설계 단계

- 개념적 설계 : 트랜잭션 모델링/ 독립적인 개념 스키마 모델링/ 개념스키마 설계/ E-R 다이어그램
- 논리적 설계 : 트랜잭션 인터페이스 설계/ DBMS에 맞는 논리스키마 설계/ 테이블 설계/ 논리적 매핑/ 스키마 평가 및 정제
- 물리적 설계 : 레코드 집중의 분석,설계/ 저장레코드 양식 설계 / 저장 구조 및 액세스 경로 설정
  <br>
  <br>

55. 테이블의 기본키(Primary Key)

- 후보키 중에서 선정된 주키(MAIN KEY)로 중복된 값을 가질 수 없음
- 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성
- 기본키는 후보키의 성질을 갖음 즉 튜플을 식별하기 위해 반드시 필요한 키
- 기본키는 NULL 값을 가질 수 없음
- 검색할때 반드시 필요한 것은 아님
- 하지만 기본키로 검색하면 유일한 튜플을 조회할 수 있음
  <br>
  <br>

56. 데이터 모델의 구성 요소

- 구조(Structure) : 논리적인 개체 타입들 간의 관계, 데이터 구조 및 정적 성질을 표현
- 연산(Operation) : 실제 데이터를 처리하는 작업에 대한 명세로, 조작하는 기본 도구
- 제약 조건(Constraint) : DB에 저장될 수 있는 실제 데이터의 논리적인 제약 조건
  <br>
  <br>

57. SQL문
    <br>
    <br>

58. 무결성 제약조건

- 개체 무결성 : 각 릴레이션의 기본키를 구성하는 속성은 널(NULL) 값이나 중복된 값을 가질 수 없음
- 참조무결성 : 외래키 값은 NULL이거나 참조하는 릴레이션의 기본키 값과 동일해야 함
- 도메인 무결성 : 속성들의 값은 정의된 도메인에 속한 값이어야 함
- 고유 무결성 : 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 릴레이션의 각 튜플이 가지는 속성 값들은 서로 달라야 함
- NULL 무결성 : 릴레이션의 특정 속성 값은 NULL 될 수 없음
- 키 무결성 : 각 릴레이션은 최소한 한 개 이상의 키가 존재해야함
  <br>
  <br>

59. 릴레이션

- 차수(Degree) : 속성의 수
- 카디널리티(Cardinality) : 튜플의 수 (기수)
  <br>
  <br>

60. 테이블 생성 권한 부여

- GRANT CREATE TABLE TO
  <br>
  <br>
  <br>
  <br>
  <br>

#### 프로그래밍 언어 활용

61. C언어 문자열 처리 함수 서식

- strlen(s) : s의 길이를 구함
- strcpy(s1, s2) : s2를 s1으로 복사
- strrev(s) : s를 거꾸로 변환
- strcat(s1, s2) : 문자열 연결
- strcmp(s1, s2) : 문자열 비교
  <br>
  <br>

62, 63. C언어

- C언어 연산자에서는 0이 아닌 모든값은 1(True)
  <br>
  <br>

64. IP 프로토콜 필드

- Header Length : IP 프로토콜의 헤더 길이를 32비트 워드 단위로 표시
- Packet Length (16 bits): IP 헤더 및 데이터를 포함한 IP 패킷 전체 길이를 바이트 단위로 길이를 표시 (최대값은 65,535 = 2^16 - 1)
- Time To Live : 송신 호스트가 패킷을 전송하기 전 네트워크에서 생존할 수 있는 시간을 지정한 것
- Version Number는 IP 프로토콜의 버전번호를 나타냄
  <br>
  <br>

65. Python 조건문

- if elif else
  <br>
  <br>

66. RIP

- 최단 경로 탐색에는 Bellman-Ford 알고리즘을 사용하는 거리 벡터 라우팅 프로토콜
- 라우팅 프로토콜을 IGP와 EGP로 분류했을 때 IGP에 해당
- 최적의 경로를 산출하기 위한 정보로서 홉(거리 값)만을 고려하므로, RIP을 선택한 경로가 최적의 경로가 아닌 경우가 많이 발생할 수 있음
- 소규모 네트워크 환경에 적합
- 최대 홉 카운트를 15홉 이하로 한정
  <br>
  <br>

67. HRN 스케줄링

- 비선점 스케줄링
  <br>
  <br>

68. UNIX

- 주로 서버영 컴퓨터에서 사용됨
- time sharing system을 위해 설계된 대화식 운영체제
- c언어로 작성되어 이식성 높고 장치간 호환성 높음
- Multi user, Multi tasking 모두 지원
- 트리 구조의 파일 시스템
  <br>
  <br>

69. UDP 프로토콜

- 비연결형 및 비신뢰성 전송 서비스 제공
- 흐름 제어나 순서 제어가 없어 전송 속도 빠름
- 수신된 데이터의 순서 재조정 기능을 지원하지 않음
- 복구 기능 제공하지 않음
- TCP와 같이 트랜스포트 계층 존재
- 단순한 헤더 구조로 오버헤드가 적음
  <br>
  <br>

70. 튜플 타입

- Python 데이터 타입 중 시퀀스 데이터 타입
- 다양한 데이터 타입들을 주어진 순서에 따라 저장할 수 있으나 저장된 내용을 변경할 수는 없음
  <br>
  <br>

71, 72. JAVA 문제
<br>
<br>

73. 응집도

- (강함) 기능적 응집도 > 순차적 응집도 > 교환적 응집도 > 절차적 응집도 > 시간적 응집도 > 논리적 응집도 > 우연적 응집도 (약함)
  <br>
  <br>

74. C언어
    <br>
    <br>

75. IP 프로토콜 특징

- 데이터 체크섬은 제공하지 않고 헤더 체크섬만 제공
- 패킷을 분할, 병합하는 기능 수행
- 비연결형 서비스 제공
- Best Effort 원칙에 따른 전송 기능 제공
  <br>
  <br>

76. LRU 교체 알고리즘
    <br>
    <br>

77. 사용자 스레드의 장점

- 커널 모드로의 전환 없이 스레드 교환이 가능하므로 오버헤드가 줄어듬
  <br>
  <br>

78. 결합도

- 스탬프 결합도 : 두 모듈이 매개변수로 자료를 전달할 때. 자료구조 형태로 전달되어 이용될 때
- 내용 결합도 : 하나의 모듈이 직접적으로 다른 모듈의 내용을 참조할 때
- 공통 결합도 : 두 모듈이 동일한 전역 데이터를 접근할 때
  <br>
  <br>

79. C언어
    <br>
    <br>

80. 모듈화

- 시스템을 모듈로 분할하면 각각의 모듈을 별개로 만들고 수정할 수 있어서 좋은 구조가 됨
- 응집도 : 하나의 모듈이 하나의 기능을 수행하는 요소들간의 연관성 척도, 독립적인 모듈이 되기 위해서는 응집도가 강해야 함
- 결합도 : 모듈과 모듈 사이의 상호의존 또는 연관 정도를 의미
  <br>
  <br>
  <br>
  <br>
  <br>

#### 정보시스템 구축관리

81. 정보보안 3요소

- 무결성, 기밀성, 가용성
  <br>
  <br>

82. TCP

- TCP는 3-way handshake를 통해 통신이 원활히 이루어질 수 있는지 확인함.
- 어떤 외부 컴퓨터가 접속되면 접속 인가 여부를 점검해서 인가된 경우에는 접속이 허용되고, 그 반대의 경우에는 거부할 수 있는 접근제어 유틸리티
  <br>
  <br>

83. Zing

- 기기를 키오스크에 갖다 대면 원하는 데이터를 바로 가져올 수 있는 기술
- 10cm 이내 근접 거리에서 기가급 속도로 데이터 전송이 가능한 초고속 근접무선통신
  <br>
  <br>

84. 응용프로그램 취약점 관리

- 패치관리 : 응용프로그램에 대한 패치 또는 서비스팩 적용
- 응용프로그램 실행권한의 제한 필요
- 운영체제의 접근 제한
- 정보 수집 제한
- 불필요한 서비스 및 악성 프로그램의 확인 및 제거
- 시스템 무결성 검사 : 주요 파일을 검사하여 변경 내역 확인
  <br>
  <br>

85. 소프트웨어 개발 프레임워크

- 반제품 상태의 제품을 토대로 도메인별로 필요한 서비스 컴포넌트를 사용하여 재사용성 확대화 성능을 보장 받을 수 있게 하는 개발 소프트웨어
- 이미 정해진 코드를 호출해 사용하고 자체적인 흐름을 가지고 있음
- 설계 관점에 개발 방식을 패턴화시키기 위한 노력의 결과물인 소프트웨어 디자인 패턴을 반제품 소프트웨어 상태로 집적화 시킨 것
- 프레임워크의 동작 원리를 그 제어 흐름의 일반적인 프로그램 흐름과 반대로 동작한다고 해서 IoC이라고 설명하기도 함
  <br>
  <br>

86. HSM

- 클라우드 기반 암호화 키 생성, 처리, 저장 등을 하는 보안 기기
- 국내에서는 공인인증제 폐지와 전자서명법 개정을 추진하면서 클라우드 HSM 용어가 자주 등장
- 하드웨어적으러 구현되므로 소프트웨어식 암호 기술에 내재된 보안 취약점 해결할 수 있음
  <br>
  <br>

87. Mesh Network

- 다른 국을 향하는 호출이 중계에 의하지 않고 직접 접속되는 그물 모양의 네트워크
- 통신량이 많은 비교적 소수의 국 사이에 구성될 경우 경제적이며 간편하지만, 다수의 국 사이에는 회선이 세분화되어 비경제적일 수도 있음
- 해당 형태의 무선 네트워크의 경우 대용량을 빠르고 안전하게 전달할 수 있어 행사장이나 군 등에서 많이 사용
  <br>
  <br>

88. 물리적 위협

- 화재, 홍수 등 천재지변으로 인한 위협
- 하드웨어 파손, 고장으로 인한 장애
- 방화,.테러로 인한 하드웨어와 기록장치를 물리적으로 파괴하는 행위
  <br>
  <br>

89. 악성코드

- Worm : 다른 컴퓨터의 취약점을 이용하여 스스로 전파하거나 메일로 전파되며 스스로를 증식
- Rogue Ware(Rogue security software; 가짜 백신 소프트웨어) : 사용자가 컴퓨터에 바이러스가 있다고 잘못 믿게 하고 컴퓨터에 실제로 악성 프로그램을 설치토록 하거나, 가짜 악성 프로그램 제거 도구에 대한 비용을 지불하도록 설득함, 공포심을 통해 사용자를 조종
- Adware : 특정 소프트웨어를 실행할 때 또는 자동으로 활성화되는 광고프로그램으로 이 자체는 악성코드로 보기는 힘들지만, 무분별한 광고 팝업을 뜨게 하는 등의 악용 위험성으로 악성코드로 분류되기도 함
- Reflection Attack(반사공격) : 송신자가 생성한 메시지를 가로챈 공격자가 그 메시지를 다시 송신자에게 재전송하여 접근 권한을 얻는 형태의 공격 방법.
  <br>
  <br>

90. 공격기법

- Ping of Death : 허용범위 이상의 ICMP 패킷을 전송하여 대상 시스템의 네트워크를 마비시킴
- Session Hijacking(세션 가로채기) : 컴퓨터 시스템의 정보나 서비스에 무단으로 접근하기 위해 유효한 컴퓨터 세션(세션 키라고도 함)을 이용하는 것 일반적인 예로 두 컴퓨터 간에 활성화된 상태(즉, 로그인된 상태)에서 공격자가 피공격자의 로그인 정보를 활용하여 자신에게 필요한 행위를 하는 것을 뜻함
- Piggyback Attack(피그백 공격) : 공격자가 다른 사용자의 연결에서 계정을 사용하지 않는 비활성 기간(비활성 간격)을 이용하여 시스템에 액세스(접근) 이는 간선(회선 간) 공격이라고도 불림
- XSS (크로스 사이트 스크립팅) : 웹사이트에 악성 스크립트를 주입하는 행위. 공격자가 상대방의 브라우저에 스크립트가 실행되도록 해 사용자의 세션을 가로채거나, 웹사이트를 변조하거나, 악의적 콘텐츠를 삽입하거나, 피싱 공격을 진행하는 것
  <br>
  <br>

91. 소프트웨어 개발 프레임워크

- 개발해야 할 애플리케이션의 일부분이 이미 내장된 클래스 라이브러리로 구현이 되어 있음
- 그 기반이 되는 이미 존재하는 부분을 확장 및 이용하는 것
  <br>
  <br>

92. Agile 방법론 특징

- 소프트웨어 개발에 참여하는 구성원들 간의 의사소통 중시
- 환경 변화에 대한 즉시 대응
- 프로젝트 상황에 따른 주기적 조정
  <br>
  <br>

93. 대칭 암호 알고리즘, 비대칭 암호 알고리즘

- 대칭 암호 알고리즘은 비교적 실행 속도가 빠르기 때문에 다양한 암호의 핵심 함수로 사용 됨
- 대칭 암호화 알고리즘은 키 교환이 필요하기 떄문에 키를 교환하는 중 키가 탈취될 수 있다는 문제 있음
- 비대칭 암호 알고리즘은 자신만이 보관하는 비밀키를 이용하여 인증, 전자서명 등 적용 가능
  <br>
  <br>

94. 생산성 측정

- 생산성 = LOC/노력(사람x월)
  <br>
  <br>

95. 접근 통제 방법

- RBAC : 권한이 있는 사용자들만 접근할 수 있는 보안 방법, 직무, 직책 등 개인의 역할에 따라 결정
- DAC : 임의적 접근 통제, 사용자나 그룹의 신분에 따라 제한, 자원 소유권을 가진 사람이 다른 사람의 접근을 허용하거나 제한할 수 있음
- MAC : 강제 접근 통제
  <br>
  <br>

96. COCOMO모형 특징

- 프로젝트를 완성하는데 필요한 man-month로 산정 결과 나타낼 수 있음
- 보헴이 제안한 것으로 원시코드 라인 수에 의한 비용 산정 기법
- 비교적 작은 규모의 프로젝트 기록을 통계 분석하여 얻은 결과를 반영한 모델이며 중소 규모 소프트웨어 프로젝트 비용 추정할 때 적합
  <br>
  <br>

97. 사용자의 인증 유형

- 지식 : 본인이 알고 있는 것(ex. 패스워드, PIN 등)
- 소유 : 본인이 가지고 있는 것(ex. 토큰, 스마트카드 등)
- 존재 : 본인을 나타내는 것(ex. 홍채, 지문 등)
- 행위 : 본인이 하는 것(ex. 서명, 움직임, 음성 등)
  <br>
  <br>

98. Authentication

- 자신의 신원을 시스템에게 증명하는 과정
- 아이디와 패스워드 입력
  <br>
  <br>

99. SDN

- 네트워크를 제어부, 데이터 전달부로 분리하여 네트워크 관리자가 보다 효율적으로 네트워크를 제어, 관리할 수 있는 기술
- 기존의 라우터, 스위치 등과 같이 하드웨어에 의존하는 네트워크 체계에서 안정성, 속도, 보안 등을 소프트웨어로 제어, 관리하기 위해 개발됨
- 네트워크 장비의 펌웨어 업그레이드를 통해 사용자의 직접적인 데이터 전송 경로 관리가 가능하고, 기존 네트워크에는 영향을 주지 않으면서 특정 서비스의 전송 경로 수정을 통하여 인터넷상에서 발생하는 문제를 처리할 수 있음
  <br>
  <br>

100. PERT차트

- 작업들 간의 상호 관련성, 결정경로, 경계시간, 자원할당 등을 제시함
